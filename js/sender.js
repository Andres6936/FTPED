import fs from 'fs'
import path from 'path'
import ftp from 'basic-ftp'

/**
 * A possible problem when using a folder to send these files to an
 * FTP is the synchronization and the speed with which these files are
 * sent, given a hypothetical case where a new cycle starts, the
 * configuration of the FTP connection will start and the files
 * located there will be sent, However, there is the possibility that
 * while the files are being sent a new file is placed there, this
 * file will not be sent to the FTP but it will be registered as a
 * sent file when it is moved to the backup folder where the files
 * sent to the FTP are stored.
 *
 * To avoid this problem we will use a folder where the files will be
 * stored before being sent, with this we ensure that if and only if,
 * the files located here will be sent.
 *
 * This folder will be for the exclusive use of the service and should
 * not be used for any other purpose.
 *
 * @type {string}
 */
const DIRECTORY_STAGE = 'stage/';

/**
 * Checks the existence of the directory, if this directory does not exist it
 * creates it, the default function suppresses the error generated by trying
 * to create a directory that already exists, if you wish to obtain this
 * behavior avoid using this function.
 *
 * @param directory Directory to verify the existence.
 * @returns {Promise<void>} None.
 */
export async function verifyDirectory(directory) {
    try {
        await fs.promises.mkdir(directory)
    } catch (ignored) {
    }
}

/**
 * Move all the files from directory to directory, if the destination
 * directory not exist it function created the directory, if the user
 * that execute this service not had the permissions for read (move)
 * the files it function change the permissions and read (move) the files.
 *
 * @param {string} from Directory from the current files are stored.
 * @param {string} to Destination directory from the files will be saved.
 * @returns {Promise<void>} None
 */
async function moveAllFiles(from, to) {
    // Created the directory if not exist
    await verifyDirectory(to);
    fs.readdir(from, (err, files) => {
        if (err) throw err;

        for (const file of files) {
            const pathFrom = path.join(from, file);
            // For the generally, the service that move the files to
            // directory where we take the files set the permissions
            // for this files for he, however, when we trying read
            // (move) the files a exception is thrown.

            // Change the permissions of each file to move, in this case
            // the permissions that needed are:
            fs.chmod(pathFrom,
                // Constant for fs.Stats mode property for determining access
                // permissions for a file. File mode indicating readable,
                // writable and executable by group.
                fs.constants.S_IRWXG |
                // Constant for fs.Stats mode property for determining access
                // permissions for a file. File mode indicating readable,
                // writable and executable by others.
                fs.constants.S_IRWXO,
                err => {
                    if (err) throw err;
                    console.log('The permissions for file' + pathFrom + ' have been changed!');
                });

            fs.rename(pathFrom, path.join(to, file), err => {
                if (err) throw err;
            });
        }
    });
}

/**
 * This function is executed only if two conditions are true, the first
 * condition is that there is at least one file in the directory and the
 * second condition is that no other process is blocking the directory.
 *
 * A problem that can occur with this function is that it produces a
 * deadlock, since the existence of a dummy file (in this case a .lock
 * that is used to determine the lock of the directory) can cause the
 * function to stop executing, blocking the other processes that need
 * to access this directory, to avoid this type of problem two conditions
 * must be met:
 *
 * The first condition is that only one function must be in charge of
 * creating the dummy file (in this case the .lock), the second condition
 * is that the function that is in charge of creating the dummy file must
 * be the same function that must also be in charge of deleting it once
 * the directory has been released.
 *
 * @returns {Promise<void>} None
 */
export async function sendFiles() {
    // We verify that the conditions mentioned above are met, i.e., that
    // there is more than one file in the directory and that it is released
    // by another function
    if (fs.readdirSync(process.env.DIRECTORY_BUCKET).length === 0 &&
        fs.readdirSync(DIRECTORY_STAGE).length === 0) return;

    await console.log("Begin cycle");
    // The timeout is set to 180 seconds (3 minutes)
    const client = new ftp.Client(180_000);
    // Only for debug session
    client.ftp.verbose = (process.env.DEBUG === 'true');
    try {
        // We make the connection to the FTP server, a feature of this
        // connection is: Unlike a previous implementation, this connection
        // will only be established if there is at least one file to send,
        // if there is no file to send the connection will not be established,
        // saving network resources and avoiding the blocking of the IP by a
        // constant PING done day and night (non-stop).
        await client.access({
            host: process.env.FTPS_HOST,
            port: process.env.FTPS_PORT,
            user: process.env.FTPS_USER,
            password: process.env.FTPS_PASS,
            // Only allow insecure connection with debug flag active (This is
            // useful only when a developer is working), for production it
            // flag is true, meaning that any attempt to connect to an FTP
            // with a self-signed or expired certificate will fail as an
            // exception will be thrown.
            secure: true,
        })

        // Log progress for any transfer from now on.
        client.trackProgress(info => {
            if (process.env.DEBUG === 'true') {
                console.log("File", info.name)
                console.log("Type", info.type)
                console.log("Transferred", info.bytes)
                console.log("Transferred Overall", info.bytesOverall)
            }
        })

        let destinationPath = process.env.FTPS_DIR;
        if (!destinationPath.endsWith('/')) {
            destinationPath += '/'
        }

        await moveAllFiles(process.env.DIRECTORY_BUCKET, DIRECTORY_STAGE);
        // Make sure a given remote path exists, creating all directories as
        // necessary. This function also changes the current working directory
        // to the given path.
        await client.ensureDir(destinationPath);
        // Upload the contents of a local directory to the remote working
        // directory.
        // This will overwrite existing files with the same names and reuse
        // existing directories. Unrelated files and directories will remain
        // untouched. You can optionally provide a remoteDirPath to put the
        // contents inside a directory which will be created if necessary
        // including all intermediate directories. If you did provide a
        // remoteDirPath the working directory will stay the same as before
        // calling this method.
        await client.uploadFromDir(DIRECTORY_STAGE);
        await moveAllFiles(DIRECTORY_STAGE, process.env.DIRECTORY_BACKUP);
    } catch (err) {
        console.error('Exception thrown, cause: ' + err.message + "\n\nSee trace: " + err);
    }
    await client.close()
}